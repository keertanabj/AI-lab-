import heapq

# Goal state
GOAL = (1, 2, 3,
        4, 5, 6,
        7, 8, 0)

MOVES = {
    'U': -3,
    'D': 3,
    'L': -1,
    'R': 1
}

def is_valid_move(pos, move):
    if move == 'U' and pos < 3: return False
    if move == 'D' and pos > 5: return False
    if move == 'L' and pos % 3 == 0: return False
    if move == 'R' and pos % 3 == 2: return False
    return True

def neighbors(state):
    new_states = []
    pos = state.index(0)
    for move, offset in MOVES.items():
        if is_valid_move(pos, move):
            new_pos = pos + offset
            new_state = list(state)
            new_state[pos], new_state[new_pos] = new_state[new_pos], new_state[pos]
            new_states.append((tuple(new_state), move))
    return new_states

def manhattan(state):
    distance = 0
    for idx, value in enumerate(state):
        if value == 0:
            continue
        goal_idx = GOAL.index(value)
        r1, c1 = divmod(idx, 3)
        r2, c2 = divmod(goal_idx, 3)
        distance += abs(r1 - r2) + abs(c1 - c2)
    return distance

def is_solvable(state):
    flat = [x for x in state if x != 0]
    inversions = 0
    for i in range(len(flat)):
        for j in range(i + 1, len(flat)):
            if flat[i] > flat[j]:
                inversions += 1
    return inversions % 2 == 0

def reconstruct_path(parent, current):
    path = [current]
    while current in parent:
        current = parent[current]
        path.append(current)
    return path[::-1]

def print_board(state):
    for i in range(0, 9, 3):
        row = state[i:i+3]
        print(" ".join(str(x) if x != 0 else " " for x in row))
    print()

def a_star(start):
    if not is_solvable(start):
        return None

    open_list = []
    g = {start: 0}
    parent = {}

    heapq.heappush(open_list, (manhattan(start), start))

    while open_list:
        f, current = heapq.heappop(open_list)

        if current == GOAL:
            return reconstruct_path(parent, current)

        for neighbor, _ in neighbors(current):
            tentative_g = g[current] + 1
            if neighbor not in g or tentative_g < g[neighbor]:
                g[neighbor] = tentative_g
                f_score = tentative_g + manhattan(neighbor)
                heapq.heappush(open_list, (f_score, neighbor))
                parent[neighbor] = current

    return None

# --- MAIN PROGRAM ---
if __name__ == "__main__":
    print("Enter the 8-puzzle start state row by row (use 0 for blank):")
    input_state = []
    for i in range(3):
        row = input(f"Row {i + 1}: ").strip().split()
        input_state.extend([int(x) for x in row])
    start = tuple(input_state)

    solution_path = a_star(start)

    if solution_path:
        print(f"\nSolution found in {len(solution_path) - 1} moves:\n")
        for step_num, state in enumerate(solution_path):
            print(f"Step {step_num}:")
            print_board(state)
    else:
        print("\nThis puzzle configuration is unsolvable.")
