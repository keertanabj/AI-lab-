def dls(node, target, depth, tree, visited):
    # If depth is less than 0, return False
    if depth < 0:
        return False

    # Add the current node to visited
    visited.append(node)

    # If the node is the target, return True
    if node == target:
        return True

    # If the node has no children in the tree, return False
    if node not in tree:
        return False

    # Search through all the children of the current node
    for child in tree[node]:
        if dls(child, target, depth - 1, tree, visited):
            return True

    return False

def iddfs(root, target, max_depth, tree):
    # For storing the path traversed
    trace = []
    
    # Perform depth-limited search with increasing depth
    for depth in range(max_depth + 1):
        visited = []  # reset visited for each depth iteration
        
        # Call DLS for current depth
        if dls(root, target, depth, tree, visited):
            trace = visited  # Save the path if target is found
            break

    return trace

# Define the tree structure as a dictionary
tree = {
    'a': ['b', 'c'],
    'b': ['d', 'e'],
    'c': ['f', 'g'],
    'd': ['h'],
    'f': ['i']
}

# Run IDDFS to find the target node 'g'
trace = iddfs('a', 'g', 4, tree)

# Output the traversal path
print("Traversal path to 'g':", trace)
