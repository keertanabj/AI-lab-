def heuristic(state):
    attacks = 0
    n = len(state)
    for i in range(n):
        for j in range(i + 1, n):
            if state[i] == state[j]:
                attacks += 1
            if abs(state[i] - state[j]) == abs(i - j):
                attacks += 1
    return attacks

def get_neighbors(state):
    neighbors = []
    n = len(state)
    for col in range(n):
        for row in range(n):
            if state[col] != row:
                new_state = list(state)
                new_state[col] = row
                neighbors.append(new_state)
    return neighbors

def hill_climbing(initial_state):
    current = initial_state
    current_heuristic = heuristic(current)
    
    while True:
        neighbors = get_neighbors(current)
        next_state = current
        next_heuristic = current_heuristic
        
        for state in neighbors:
            h = heuristic(state)
            if h < next_heuristic:
                next_state = state
                next_heuristic = h
                
        if next_heuristic == current_heuristic:
            break
        
        current = next_state
        current_heuristic = next_heuristic
    
    return current, current_heuristic

def get_user_input():
    while True:
        try:
            user_input = input("Enter the initial state (4 numbers between 0 and 3 separated by spaces): ")
            state = list(map(int, user_input.strip().split()))
            if len(state) != 4 or any(r < 0 or r > 3 for r in state):
                raise ValueError
            return state
        except ValueError:
            print("Invalid input. Please enter exactly 4 numbers between 0 and 3 separated by spaces.")

def generate_all_states(n):
    if n == 0:
        return [[]]
    smaller_states = generate_all_states(n - 1)
    states = []
    for state in smaller_states:
        for row in range(4):
            states.append(state + [row])
    return states

def run_all_states():
    n = 4
    all_states = generate_all_states(n)
    solutions = set()
    count_solutions = 0
    count_local_minima = 0

    for state in all_states:
        final_state, cost = hill_climbing(state)
        if cost == 0:
            solutions.add(tuple(final_state))
            count_solutions += 1
        else:
            count_local_minima += 1

    print(f"\nTotal initial states: {len(all_states)}")
    print(f"Solutions found: {len(solutions)} unique solutions")
    print(f"States stuck in local minima without solution: {count_local_minima}")
    print("\nUnique solutions:")
    for sol in solutions:
        print(sol)

def main():
    initial = get_user_input()
    solution, cost = hill_climbing(initial)

    print(f"\nInitial state: {initial}")
    print(f"Final state: {solution}")
    print(f"Conflicts: {cost}")

    if cost == 0:
        print("Solution found! No conflicts.")
    else:
        print("Reached a local minimum but no solution.")

    run_all = input("\nDo you want to find all unique solutions by running hill climbing on all possible initial states? (yes/no): ").strip().lower()
    if run_all == 'yes':
        run_all_states()
    else:
        print("Done.")

if __name__ == "__main__":
    main()
